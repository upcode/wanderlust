



<!--
    <!--SEECOND COL IN THE FIRST CONTAINER-->
    <div class="container-fluid" id="postcards">
      <div class="row">
        <div class="col-xs-12 col-md-8">
            <div class="row">
              <div class="col-md-7">
                <div class="well well-sm">
                  <div class="media">
                    <center><a class="thumbnail center" href="#">
                        <img class="media-object" src="static/img/dashboard.jpg">
                        </a></center>
                          <div class="media-body">
                            <div class="col-md-8">
                              <center><h3>My Postcards</h3></center>
                                    <form action='/postcard' method="POST" enctype="multipart/form-data">
                                      <p><input type='file' name='postcard' multiple=''>
                                      <input type='submit' value='upload'></p>
                                    </form>
                            </div>
                          </div>
                    </div>
                  </div>
              </div>
          </div>
      </div>
    </div>
</div>
 -->




<script src="http://d3js.org/d3.v3.min.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="http://d3js.org/queue.v1.min.js"></script>
    <script src="static/js/d3_world_map.js"></script>
<!--   d3 World Map that unreels into flat map
 -->
<div class="container-fluid">
    <div class="row">
         <div class="col-md-6 col-md-offset-1">

  <div id="map"></div>
  </div>
</div>
 <script>
// d3 world map javascript
// Map hight and width
var mapWidth = 860,
  mapHeight = 400,
  focused = false,
  ortho = true,
  sens = 0.25;
// world map projection
var projectionGlobe = d3.geo.orthographic()
  .scale(140)
  .center([0, 0])
  .translate([mapWidth / 2, mapHeight / 2])
  .clipAngle(90);
var projectionMap = d3.geo.equirectangular()
  .scale(145)
  .center([0, 0])
  .translate([mapWidth / 2, mapHeight / 2])
var projection = projectionGlobe;
var path = d3.geo.path()
  .projection(projection);
var globe2map = interpolatedProjection(projectionGlobe, projectionMap),
map2globe = interpolatedProjection(projectionMap, projectionGlobe);
var svgMap = d3.select("div#map").append("svg")
  .attr("overflow", "hidden")
  .attr("width", mapWidth)
  .attr("height", mapHeight);
// Tool Tip
var zoneTooltip = d3.select("div#map").append("div").attr("class", "zoneTooltip"),
pointLlabel = d3.select("div#map").append("div").attr("class", "pointLabel"),
infoLabel = d3.select("div#map").append("div").attr("class", "infoLabel");
var g = svgMap.append("g");
//Unreelling transformation
function animation(interProj) {
  defaultRotate();
  g.transition()
  .duration(7500)
  .tween("projection", function() {
    return function(_) {
      interProj.alpha(_);
      g.selectAll("path").attr("d", path);
    };
  })
}
function interpolatedProjection(a, b) {
  var projection = d3.geo.projection(raw).scale(1),
  center = projection.center,
  translate = projection.translate,
  clip = projection.clipAngle,
  α;
  function raw(λ, φ) {
    var pa = a([λ *= 180 / Math.PI, φ *= 180 / Math.PI]), pb = b([λ, φ]);
    return [(1 - α) * pa[0] + α * pb[0], (α - 1) * pa[1] - α * pb[1]];
  }
  projection.alpha = function(_) {
    if (!arguments.length) return α;
    α = +_;
    var ca = a.center(), cb = b.center(),
    ta = a.translate(), tb = b.translate();
    center([(1 - α) * ca[0] + α * cb[0], (1 - α) * ca[1] + α * cb[1]]);
    translate([(1 - α) * ta[0] + α * tb[0], (1 - α) * ta[1] + α * tb[1]]);
    if (ortho === true) {clip(180 - α * 90);}
    return projection;
  };
  delete projection.scale;
  delete projection.translate;
  delete projection.center;
  return projection.alpha(0);
}
//Rotate to default before animation
function defaultRotate() {
  d3.transition()
  .duration(1500)
  .tween("rotate", function() {
    var r = d3.interpolate(projection.rotate(), [0, 0]);
    return function(t) {
      projection.rotate(r(t));
      g.selectAll("path").attr("d", path);
    };
  })
};
//Starter for function AFTER All transitions
function endall(transition, callback) {
  var n = 0;
  transition
  .each(function() { ++n; })
  .each("end", function() { if (!--n) callback.apply(this, arguments); });
}
//Loading data
queue()
.defer(d3.json, "/static/d3mapdata/world-110m.json")
.defer(d3.tsv, "/static/d3mapdata/world-110m-country-names.tsv")
.await(ready);
function ready(error, world, countryData) {
  var countryById = {},
  countries = topojson.feature(world, world.objects.countries).features;
  //Adding countries by name
  countryData.forEach(function(d) {
    countryById[d.id] = d.name;
  });
  //Drawing countries on the globe
  var world = g.selectAll("path").data(countries);
  world.enter().append("path")
  .attr("class", "mapData")
  .attr("d", path)
  .classed("ortho", ortho = true);
  //Drag event
  world.call(d3.behavior.drag()
    .origin(function() { var r = projection.rotate(); return {x: r[0] / sens, y: -r[1] / sens}; })
    .on("drag", function() {
      var λ = d3.event.x * sens,
      φ = -d3.event.y * sens,
      rotate = projection.rotate();
      //Restriction for rotating upside-down
      φ = φ > 30 ? 30 :
      φ < -30 ? -30 :
      φ;
      projection.rotate([λ, φ]);
      g.selectAll("path.ortho").attr("d", path);
      g.selectAll(".focused").classed("focused", focused = false);
    }))
  //Events processing
  world.on("mouseover", function(d) {
    if (ortho === true) {
      infoLabel.text(countryById[d.id])
      .style("display", "inline");
    } else {
      zoneTooltip.text(countryById[d.id])
      .style("left", (d3.event.pageX + 7) + "px")
      .style("top", (d3.event.pageY - 15) + "px")
      .style("display", "block");
    }
  })
  .on("mouseout", function(d) {
    if (ortho === true) {
      infoLabel.style("display", "none");
    } else {
      zoneTooltip.style("display", "none");
    }
  })
  .on("mousemove", function() {
    if (ortho === false) {
      zoneTooltip.style("left", (d3.event.pageX + 7) + "px")
      .style("top", (d3.event.pageY - 15) + "px");
    }
  })
  .on("click", function(d) {
    if (focused === d) return reset();
    g.selectAll(".focused").classed("focused", false);
    d3.select(this).classed("focused", focused = d);
    infoLabel.text(countryById[d.id])
    .style("display", "inline");
    //Transforming Globe to Map
    if (ortho === true) {
      defaultRotate();
      setTimeout(function() {
        projection = globe2map;
        path.projection(projection);
        animation(projection);
        g.selectAll(".ortho").classed("ortho", ortho = false);
      }
      , 1600);
    }
  });
  //Adding extra data when focused
  function focus(d) {
    if (focused === d) return reset();
    g.selectAll(".focused").classed("focused", false);
    d3.select(this).classed("focused", focused = d);
  }
  //Reset projection
  function reset() {
    g.selectAll(".focused").classed("focused", focused = false);
    infoLabel.style("display", "none");
    zoneTooltip.style("display", "none");
    //Transforming Map to Globe
    projection = map2globe;
    path.projection(projection);
    animation(projection);
    g.selectAll("path").classed("ortho", ortho = true);
  }
};

</script>
<script>
// GOOGLE MAP

// This example displays an address form, using the autocomplete feature
// of the Google Places API to help users fill in the information.

var placeSearch, autocomplete;
var componentForm = {
  street_number: 'short_name',
  route: 'long_name',
  locality: 'long_name',
  administrative_area_level_1: 'short_name',
  country: 'long_name',
  postal_code: 'short_name'
};

function initAutocomplete() {
  // Create the autocomplete object, restricting the search to geographical
  // location types.
  autocomplete = new google.maps.places.Autocomplete(
      /** @type {!HTMLInputElement} */(document.getElementById('autocomplete')),
      {types: ['geocode']});

  // When the user selects an address from the dropdown, populate the address
  // fields in the form.
  autocomplete.addListener('place_changed', fillInAddress);
}

function fillInAddress() {
  // Get the place details from the autocomplete object.
  var place = autocomplete.getPlace();

  for (var component in componentForm) {
    document.getElementById(component).value = '';
    document.getElementById(component).disabled = false;
  }

  // Get each component of the address from the place details
  // and fill the corresponding field on the form.
  for (var i = 0; i < place.address_components.length; i++) {
    var addressType = place.address_components[i].types[0];
    if (componentForm[addressType]) {
      var val = place.address_components[i][componentForm[addressType]];
      document.getElementById(addressType).value = val;
    }
  }
}

// Bias the autocomplete object to the user's geographical location,
// as supplied by the browser's 'navigator.geolocation' object.
function geolocate() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(function(position) {
      var geolocation = {
        lat: position.coords.latitude,
        lng: position.coords.longitude
      };
      var circle = new google.maps.Circle({
        center: geolocation,
        radius: position.coords.accuracy
      });
      autocomplete.setBounds(circle.getBounds());
    });
  }
}




<!-- IMAGE I WORKED ON WITH MASON -->
 <header><img src="/static/img/logo.jpg" id="logo">
                              <h4 class="modal-title" id="myModalLabel">Create A Postcard</h4>
                            </header>
                              <div class="modal-body">
                               <form action='/postcard' method="POST" enctype="multipart/form-data">
                                    <p><input type='file' name='passportpic' multiple=''>
                                <input type='submit' value='upload'>
                                    </p>
                                </form>